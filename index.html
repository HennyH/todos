<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Git Store</title>
    <style>
        *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif}
        body{max-width:640px;margin:40px auto;padding:20px;line-height:1.5;color:#24292f}
        h1{border-bottom:3px solid #24292f;padding-bottom:12px}
        .panel{background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:24px;margin:20px 0}
        .hidden{display:none}
        button{background:#2ea44f;color:white;border:1px solid rgba(27,31,36,0.15);border-radius:6px;padding:10px 20px;font-size:14px;font-weight:500;cursor:pointer}
        button:disabled{opacity:0.6;cursor:not-allowed}
        button.secondary{background:#f6f8fa;color:#24292f;border-color:#d0d7de}
        input[type="text"]{width:100%;padding:10px;border:1px solid #d0d7de;border-radius:6px;margin:8px 0;font-size:14px}
        .hint{font-size:13px;color:#57606a;margin-top:8px}
        .error{color:#cf222e}
        .success{color:#1a7f37}
        .todo-list{border:1px solid #d0d7de;border-radius:8px;margin:16px 0}
        .todo-item{display:flex;align-items:center;padding:12px;border-bottom:1px solid #d0d7de;gap:12px}
        .todo-item:last-child{border-bottom:none}
        .todo-item.done span{text-decoration:line-through;color:#6e7781}
        code{background:#eaeef2;padding:2px 6px;border-radius:3px;font-size:12px}
    </style>
</head>
<body>
<h1>üîê Secure Git Store</h1>

<div id="step-identity" class="panel">
    <h3>Create Your Identity</h3>
    <p>Generate cryptographic keys to encrypt your data.</p>
    <button onclick="app.createIdentity()" id="btn-create-id">Generate Identity</button>
    <div id="identity-status" class="hint"></div>
</div>

<div id="step-auth" class="panel hidden">
    <h3>Connect to GitHub</h3>
    <p>One-click login to sync encrypted data.</p>
    <button onclick="app.login()" class="secondary">Log in with GitHub</button>
</div>

<div id="step-app" class="hidden">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
        <div><div style="font-weight:600">My Todos</div><div style="font-size:12px;color:#57606a" id="user-info"></div></div>
        <button onclick="app.logout()" class="secondary" style="font-size:12px">Disconnect</button>
    </div>
    <div style="display:flex;gap:8px;margin-bottom:16px">
        <input type="text" id="todo-input" placeholder="Add a todo..." onkeypress="if(event.key==='Enter')app.addTodo()" style="flex:1">
        <button onclick="app.addTodo()">Add</button>
    </div>
    <div id="todos-container" class="todo-list"></div>
    <button onclick="app.sync()" id="btn-sync" style="width:100%;background:#24292f;margin-top:20px">üíæ Save to GitHub</button>
    <div id="sync-status" class="hint" style="margin-top:8px"></div>
</div>

<script>
// ==================== CONFIGURATION ====================
const CONFIG = {
    REPO_OWNER: 'HennyH',           // Your GitHub username
    REPO_NAME: 'todos',           // Repository name (e.g., 'todo-store')
    VERCEL_API_URL: 'https://todos-blond-xi-94.vercel.app', // Vercel deployment URL
    SHOP_PUBLIC_KEY: {                     // Shop owner P-256 public key (JWK)
        kty: 'EC',
        crv: 'P-256',
        x: 'M6JVZzBRi1YUTsC6Zr1jmaJ0h7fJznx5voY6wrxka-E',
        y: 'wPDtNEu87t8qV9XXHR74dYAYda46yZSuuq_r9Knz6QI'
    }
};


// ==================== CRYPTO UTILITIES ====================
const b64u = buf => btoa(String.fromCharCode(...new Uint8Array(buf))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=/g,'');
const ub64u = str => { str=str.replace(/-/g,'+').replace(/_/g,'/'); while(str.length%4)str+='='; return Uint8Array.from(atob(str),c=>c.charCodeAt(0)) };
const base58 = bytes => { const a='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'; let n=BigInt('0x'+Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('')),s=''; while(n>0){s=a[Number(n%58n)]+s;n/=58n} for(let b of bytes)if(b===0)s='1'+s; return s };

class CryptoManager{
    async generateIdentity(){
        const k=await crypto.subtle.generateKey({name:'ECDH',namedCurve:'P-256'},true,['deriveKey','deriveBits']);
        const pub=await crypto.subtle.exportKey('jwk',k.publicKey);
        const priv=await crypto.subtle.exportKey('jwk',k.privateKey);
        const raw=await crypto.subtle.exportKey('raw',k.publicKey);
        const h=await crypto.subtle.digest('SHA-256',raw);
        return{privateKey:pub,publicKey:pub,address:base58(new Uint8Array(h).slice(0,20))};
    }
    async loadIdentity(stored){
        const priv=await crypto.subtle.importKey('jwk',stored.privateKey,{name:'ECDH',namedCurve:'P-256'},false,['deriveKey','deriveBits']);
        const pub=await crypto.subtle.importKey('jwk',stored.publicKey,{name:'ECDH',namedCurve:'P-256'},true,[]);
        return{privateKey:priv,publicKey:pub,address:stored.address};
    }
    async dualEncrypt(plaintext,userPub,shopPubJwk){
        const shopPub=await crypto.subtle.importKey('jwk',shopPubJwk,{name:'ECDH',namedCurve:'P-256'},true,[]);
        const cek=await crypto.subtle.generateKey({name:'AES-GCM',length:256},true,['encrypt','wrapKey']);
        const iv=crypto.getRandomValues(new Uint8Array(12));
        const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},cek,new TextEncoder().encode(JSON.stringify(plaintext)));
        const wrap=async(rp,kid)=>{
            const ep=await crypto.subtle.generateKey({name:'ECDH',namedCurve:'P-256'},true,['deriveKey']);
            const sb=await crypto.subtle.deriveBits({name:'ECDH',public:rp},ep.privateKey,256);
            const wk=await crypto.subtle.importKey('raw',sb,{name:'AES-KW'},false,['wrapKey']);
            const w=await crypto.subtle.wrapKey('raw',cek,wk,'AES-KW');
            const er=await crypto.subtle.exportKey('raw',ep.publicKey);
            return{kid,epk:b64u(er),wk:b64u(w)};
        };
        const rec=await Promise.all([wrap(userPub,'user'),wrap(shopPub,'shop')]);
        return{v:1,iv:b64u(iv),ct:b64u(ct),rec,ts:Date.now()};
    }
    async decrypt(enc,privateKey,kid='user'){
        const r=enc.rec.find(x=>x.kid===kid);
        if(!r)throw new Error('No key');
        const ep=await crypto.subtle.importKey('raw',ub64u(r.epk),{name:'ECDH',namedCurve:'P-256'},false,[]);
        const sb=await crypto.subtle.deriveBits({name:'ECDH',public:ep},privateKey,256);
        const wk=await crypto.subtle.importKey('raw',sb,{name:'AES-KW'},false,['unwrapKey']);
        const cek=await crypto.subtle.unwrapKey('raw',ub64u(r.wk),wk,'AES-KW',{name:'AES-GCM',length:256},false,['decrypt']);
        const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv:ub64u(enc.iv)},cek,ub64u(enc.ct));
        return JSON.parse(new TextDecoder().decode(pt));
    }
}

class GitHubStore{
    constructor(token,identity){
        this.token=token;this.identity=identity;
        this.api='https://api.github.com';
        this.raw=`https://raw.githubusercontent.com/${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}/main`;
    }
    async fetchTodos(){
        const p=`data/users/${this.identity.address}/todos.json`;
        try{
            const r=await fetch(`${this.raw}/${p}`);
            if(r.status===404)return[];
            const e=await r.json();
            return await new CryptoManager().decrypt(e,this.identity.privateKey);
        }catch(e){return[]}
    }
    async saveTodos(todos){
        const cm=new CryptoManager();
        const up=await crypto.subtle.importKey('jwk',JSON.parse(localStorage.getItem('todo_identity')).publicKey,{name:'ECDH',namedCurve:'P-256'},true,[]);
        const e=await cm.dualEncrypt(todos,up,CONFIG.SHOP_PUBLIC_KEY);
        const content=btoa(JSON.stringify(e,null,2));
        const p=`data/users/${this.identity.address}/todos.json`;
        const b=`todo-${Date.now()}`;

        const ref=await fetch(`${this.api}/repos/${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}/git/ref/heads/main`,{headers:{'Authorization':`token ${this.token}`,'Accept':'application/vnd.github.v3+json'}});
        const base=(await ref.json()).object.sha;

        await fetch(`${this.api}/repos/${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}/git/refs`,{method:'POST',headers:{'Authorization':`token ${this.token}`,'Content-Type':'application/json'},body:JSON.stringify({ref:`refs/heads/${b}`,sha:base})});

        let es;
        try{const c=await fetch(`${this.api}/repos/${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}/contents/${p}?ref=main`,{headers:{'Authorization':`token ${this.token}`}});if(c.ok)es=(await c.json()).sha}catch(e){}

        await fetch(`${this.api}/repos/${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}/contents/${p}`,{method:'PUT',headers:{'Authorization':`token ${this.token}`,'Content-Type':'application/json'},body:JSON.stringify({message:`Update ${this.identity.address}`,content:content,branch:b,...(es&&{sha:es})})});

        const pr=await fetch(`${this.api}/repos/${CONFIG.REPO_OWNER}/${CONFIG.REPO_NAME}/pulls`,{method:'POST',headers:{'Authorization':`token ${this.token}`,'Content-Type':'application/json'},body:JSON.stringify({title:`Todos: ${this.identity.address}`,head:b,base:'main',body:'Automated sync'})});
        return(await pr.json()).html_url;
    }
}

class App{
    constructor(){
        this.cm=new CryptoManager();
        this.identity=null;
        this.store=null;
        this.todos=[];
    }

    async init(){
        const params=new URLSearchParams(window.location.search);
        const code=params.get('code');
        if(code){
            await this.handleCallback(code);
            window.history.replaceState({},document.title,window.location.pathname);
            return;
        }

        const savedId=localStorage.getItem('todo_identity');
        const savedToken=sessionStorage.getItem('github_token');

        if(!savedId){
            this.show('step-identity');
        }else{
            this.identity=await this.cm.loadIdentity(JSON.parse(savedId));
            if(savedToken){
                await this.activate(savedToken);
            }else{
                this.show('step-auth');
            }
        }
    }

    show(id){['step-identity','step-auth','step-app'].forEach(s=>document.getElementById(s).classList.add('hidden'));document.getElementById(id).classList.remove('hidden')}

    async createIdentity(){
        const btn=document.getElementById('btn-create-id');
        btn.disabled=true;
        btn.textContent='Generating...';
        try{
            const id=await this.cm.generateIdentity();
            localStorage.setItem('todo_identity',JSON.stringify(id));
            this.identity=await this.cm.loadIdentity(id);
            document.getElementById('identity-status').innerHTML=`<span class="success">‚úì Created: <code>${id.address.substring(0,16)}...</code></span>`;
            setTimeout(()=>this.show('step-auth'),1000);
        }catch(e){
            document.getElementById('identity-status').textContent='Error: '+e.message;
            btn.disabled=false;
        }
    }

    async login(){
        const status=document.getElementById('auth-status');
        status.textContent='Initializing...';
        status.className='hint';

        try{
            // CRITICAL: Check if Vercel URL is configured
            if(CONFIG.VERCEL_API_URL.includes('your-project')){
                throw new Error('Please update CONFIG.VERCEL_API_URL in index.html');
            }

            const res=await fetch(`${CONFIG.VERCEL_API_URL}/api/start`);

            if(!res.ok){
                const err=await res.json().catch(()=>({error:'Unknown error'}));
                throw new Error(err.error || `HTTP ${res.status}`);
            }

            const data=await res.json();

            // CRITICAL: Validate response contains required fields
            if(!data.code_verifier || !data.login_url || !data.state){
                throw new Error('Invalid response from server');
            }

            sessionStorage.setItem('oauth_verifier',data.code_verifier);
            sessionStorage.setItem('oauth_state',data.state);

            window.location.href=data.login_url;
        }catch(e){
            console.error('Login error:',e);
            status.innerHTML=`<span class="error">Error: ${e.message}</span>`;
        }
    }

    async handleCallback(code){
        const verifier=sessionStorage.getItem('oauth_verifier');
        if(!verifier){
            alert('Session expired. Please try logging in again.');
            return;
        }

        try{
            const res=await fetch(`${CONFIG.VERCEL_API_URL}/api/callback`,{
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify({code:code,code_verifier:verifier})
            });

            if(!res.ok){
                const err=await res.json().catch(()=>({error:'Unknown error'}));
                throw new Error(err.error || `HTTP ${res.status}`);
            }

            const data=await res.json();
            if(!data.access_token)throw new Error('No token received');

            sessionStorage.setItem('github_token',data.access_token);
            sessionStorage.removeItem('oauth_verifier');

            if(!localStorage.getItem('todo_identity')){
                this.show('step-identity');
            }else{
                this.identity=await this.cm.loadIdentity(JSON.parse(localStorage.getItem('todo_identity')));
                await this.activate(data.access_token);
            }
        }catch(e){
            alert('Authentication failed: '+e.message);
            console.error(e);
        }
    }

    async activate(token){
        this.store=new GitHubStore(token,this.identity);
        document.getElementById('user-info').innerHTML=`ID: <code>${this.identity.address.substring(0,16)}...</code>`;
        this.show('step-app');
        await this.loadTodos();
    }

    async loadTodos(){
        document.getElementById('todos-container').innerHTML='<div style="padding:20px;text-align:center">Loading...</div>';
        this.todos=await this.store.fetchTodos();
        this.render();
    }

    render(){
        const c=document.getElementById('todos-container');
        if(!this.todos.length){c.innerHTML='<div style="padding:40px;text-align:center;color:#6e7781">No todos yet. Add one!</div>';return}
        c.innerHTML=this.todos.map((t,i)=>`
            <div class="todo-item ${t.done?'done':''}">
                <input type="checkbox" ${t.done?'checked':''} onchange="app.toggle(${i})">
                <span style="flex:1">${t.text.replace(/</g,'&lt;')}</span>
                <button onclick="app.delete(${i})" style="background:none;border:none;color:#cf222e;cursor:pointer;font-size:18px">√ó</button>
            </div>
        `).join('');
    }

    addTodo(){
        const inp=document.getElementById('todo-input');
        const t=inp.value.trim();
        if(!t)return;
        this.todos.push({text:t,done:false,created:Date.now()});
        inp.value='';
        this.render();
        document.getElementById('sync-status').textContent='Unsaved changes - click Save';
    }
    toggle(i){this.todos[i].done=!this.todos[i].done;this.render();document.getElementById('sync-status').textContent='Unsaved changes'}
    delete(i){this.todos.splice(i,1);this.render();document.getElementById('sync-status').textContent='Unsaved changes'}

    async sync(){
        const btn=document.getElementById('btn-sync');
        const st=document.getElementById('sync-status');
        btn.disabled=true;
        st.textContent='Encrypting and creating PR...';
        try{
            const url=await this.store.saveTodos(this.todos);
            st.innerHTML=`<span class="success">‚úì Saved!</span> <a href="${url}" target="_blank">View PR</a>`;
        }catch(e){
            st.innerHTML=`<span class="error">Error: ${e.message}</span>`;
        }finally{
            btn.disabled=false;
        }
    }

    logout(){
        sessionStorage.removeItem('github_token');
        location.reload();
    }
}

const app=new App();
window.app=app;
app.init();
</script>
</body>
</html>